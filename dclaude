#!/bin/bash
# dclaude - Dockerized Claude Code Launcher
# https://github.com/alanbem/dclaude

set -euo pipefail

# Load configuration file if exists (with validation)
CONFIG_FILE="${HOME}/.dclaude/config"
if [[ -f "$CONFIG_FILE" ]]; then
    # Validate config file is readable and not world-writable
    if [[ -r "$CONFIG_FILE" ]]; then
        if [[ -w "$CONFIG_FILE" ]] && [[ "$(stat -c %a "$CONFIG_FILE" 2>/dev/null || stat -f %A "$CONFIG_FILE" 2>/dev/null)" =~ [2367]$ ]]; then
            echo "Warning: Config file is world-writable, skipping for security" >&2
        else
            # shellcheck source=/dev/null
            source "$CONFIG_FILE"
        fi
    fi
fi

# Configuration
readonly IMAGE_NAME="${DCLAUDE_REGISTRY:-docker.io}/alanbem/dclaude"
readonly IMAGE_TAG="${DCLAUDE_TAG:-latest}"
readonly IMAGE="${IMAGE_NAME}:${IMAGE_TAG}"
readonly VOLUME_PREFIX="dclaude"
readonly DEBUG="${DCLAUDE_DEBUG:-false}"
readonly DOCKER_SOCKET="${DCLAUDE_DOCKER_SOCKET:-/var/run/docker.sock}"

# Colors for output (only if terminal supports it)
if [[ -t 1 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[1;33m'
    readonly BLUE='\033[0;34m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly NC=''
fi

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

warning() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

success() {
    echo -e "${GREEN}$1${NC}"
}

info() {
    echo -e "${BLUE}$1${NC}"
}

debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${YELLOW}Debug: $1${NC}" >&2
    fi
}

# Detect platform
detect_platform() {
    case "$(uname -s)" in
        Darwin*)
            echo "darwin"
            ;;
        Linux*)
            echo "linux"
            ;;
        MINGW*|CYGWIN*|MSYS*)
            echo "windows"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Check if Docker is installed
check_docker() {
    if ! command -v docker &> /dev/null; then
        error "Docker is not installed. Please install Docker first."
        echo "Visit: https://docs.docker.com/get-docker/" >&2
        exit 1
    fi
    debug "Docker found at: $(command -v docker)"
}

# Check if Docker daemon is running
check_docker_running() {
    if ! docker info &> /dev/null; then
        error "Docker daemon is not running. Please start Docker."
        exit 1
    fi
    debug "Docker daemon is running"
}

# Find an available port in the specified range
find_available_port() {
    local start_port=${1:-20000}
    local end_port=${2:-65000}
    local port

    for ((port=start_port; port<=end_port; port++)); do
        if ! netstat -ln 2>/dev/null | grep -q ":$port " && ! lsof -i ":$port" &>/dev/null; then
            echo "$port"
            return 0
        fi
    done

    # Fallback: use a random port if no available port found
    echo $((20000 + RANDOM % 45000))
}

# Detect network capability (host vs bridge)
detect_network_capability() {
    local cache_dir="${HOME}/.dclaude"
    local cache_file="${cache_dir}/network-mode"
    local test_timeout=10
    local server_container=""

    # Cleanup function for this function's containers
    cleanup_nettest() {
        if [[ -n "$server_container" ]]; then
            debug "Cleaning up test container: $server_container"
            docker stop "$server_container" &>/dev/null || true
            docker rm -f "$server_container" &>/dev/null || true
        fi
    }

    # Set up trap for cleanup
    trap cleanup_nettest EXIT

    # Create cache directory if it doesn't exist
    if [[ ! -d "$cache_dir" ]]; then
        mkdir -p "$cache_dir" || {
            debug "Failed to create cache directory, proceeding without cache"
            cache_file=""
        }
    fi

    # Check cache first (valid for 24 hours)
    if [[ -n "$cache_file" && -f "$cache_file" ]]; then
        local cache_age
        if cache_age=$(stat -c %Y "$cache_file" 2>/dev/null) || cache_age=$(stat -f %m "$cache_file" 2>/dev/null); then
            local current_time
            current_time=$(date +%s)
            local age_hours=$(( (current_time - cache_age) / 3600 ))

            if [[ $age_hours -lt 24 ]]; then
                local cached_mode
                if cached_mode=$(cat "$cache_file" 2>/dev/null) && [[ "$cached_mode" =~ ^(host|bridge)$ ]]; then
                    debug "Using cached network mode: $cached_mode (age: ${age_hours}h)"
                    trap - EXIT
                    echo "$cached_mode"
                    return 0
                fi
            fi
        fi
    fi

    debug "Testing network capabilities..."

    # Ensure alpine:3.19 is available
    if ! docker image inspect alpine:3.19 &>/dev/null; then
        debug "Alpine 3.19 image not found, pulling..."
        if ! docker pull alpine:3.19 &>/dev/null; then
            debug "Failed to pull alpine:3.19, falling back to bridge mode"
            trap - EXIT
            echo "bridge" | tee "$cache_file" 2>/dev/null || echo "bridge"
            return 0
        fi
        debug "Alpine 3.19 image pulled successfully"
    else
        debug "Alpine 3.19 image is available"
    fi

    # Test 1: Basic host networking support
    debug "Test 1: Basic host networking support"
    if ! timeout "$test_timeout" docker run --rm --network host alpine:3.19 \
        sh -c 'ip addr show lo | grep -q "127\.0\.0\.1"' &>/dev/null; then
        debug "Host networking not supported (basic test failed)"
        trap - EXIT
        echo "bridge" | tee "$cache_file" 2>/dev/null || echo "bridge"
        return 0
    fi

    # Test 2: Container-to-container localhost access
    debug "Test 2: Container-to-container localhost access"
    local test_port
    test_port=$(find_available_port)
    debug "Using dynamic port: $test_port"
    server_container="dclaude-nettest-$$"

    # Start test server
    if ! docker run --rm -d --name "$server_container" --network host alpine:3.19 \
        sh -c "echo 'test-response' | nc -l -p $test_port" &>/dev/null; then
        debug "Failed to start test server"
        trap - EXIT
        echo "bridge" | tee "$cache_file" 2>/dev/null || echo "bridge"
        return 0
    fi

    # Wait for server to be ready (max 5 seconds)
    debug "Waiting for test server to be ready..."
    local ready=false
    local wait_count=0
    local max_wait=50  # 5 seconds (50 * 0.1 seconds)

    while [[ $wait_count -lt $max_wait ]]; do
        if docker exec "$server_container" sh -c "netstat -ln 2>/dev/null | grep -q \":$test_port \"" &>/dev/null; then
            ready=true
            debug "Test server is ready after $((wait_count * 100))ms"
            break
        fi
        sleep 0.1
        ((wait_count++))
    done

    if [[ "$ready" != "true" ]]; then
        debug "Test server failed to become ready within 5 seconds"
        cleanup_nettest
        trap - EXIT
        echo "bridge" | tee "$cache_file" 2>/dev/null || echo "bridge"
        return 0
    fi

    # Test client connection
    local test_result="bridge"
    if timeout 5 docker run --rm --network host alpine:3.19 \
        sh -c "echo '' | nc localhost $test_port" &>/dev/null; then
        test_result="host"
        debug "Host networking fully supported"
    else
        debug "Host networking partially supported but localhost access failed"
    fi

    # Cleanup test server (handled by trap)
    cleanup_nettest

    # Cache the result
    if [[ -n "$cache_file" ]]; then
        echo "$test_result" > "$cache_file" 2>/dev/null || true
    fi

    # Platform-specific validation of detected mode
    local platform
    platform=$(detect_platform)
    case "$platform" in
        darwin)
            if [[ "$test_result" == "host" ]]; then
                debug "Host networking detected on macOS - validating compatibility"
                # On macOS, host networking should only work with Docker Desktop beta or OrbStack
                if ! docker system info 2>/dev/null | grep -qi "orbstack\|desktop.*beta" &>/dev/null; then
                    debug "Host networking may not work properly on this Docker setup for macOS"
                    warning "Host networking detected but may not work properly on macOS Docker Desktop (non-beta)"
                fi
            fi
            ;;
        windows)
            if [[ "$test_result" == "host" ]]; then
                debug "Host networking detected on Windows - this is unusual"
                warning "Host networking detected on Windows - this may indicate WSL2 or special configuration"
            fi
            ;;
        linux)
            debug "Network mode '$test_result' is expected on Linux platform"
            ;;
        *)
            debug "Unknown platform '$platform' - network mode validation skipped"
            ;;
    esac

    # Clear the trap before returning
    trap - EXIT

    debug "Network capability detection result: $test_result"
    echo "$test_result"
}

# Create Docker volumes if they don't exist
create_volumes() {
    local volumes=("${VOLUME_PREFIX}-config" "${VOLUME_PREFIX}-cache" "${VOLUME_PREFIX}-claude")

    for vol in "${volumes[@]}"; do
        if ! docker volume inspect "$vol" &> /dev/null; then
            info "Creating volume: $vol"
            if ! docker volume create "$vol" > /dev/null; then
                error "Failed to create volume: $vol"
                exit 1
            fi
        else
            debug "Volume exists: $vol"
        fi
    done
}

# Pull or update the Docker image
update_image() {
    local current_id=""
    local new_id=""

    # Get current image ID if exists
    if docker image inspect "$IMAGE" &> /dev/null; then
        current_id=$(docker image inspect "$IMAGE" --format='{{.Id}}')
        debug "Current image ID: ${current_id:0:12}"
    fi

    # Try to pull latest
    info "Checking for updates to $IMAGE..."
    if docker pull "$IMAGE" 2> /dev/null; then
        new_id=$(docker image inspect "$IMAGE" --format='{{.Id}}' 2>/dev/null || echo "")

        if [[ -z "$new_id" ]]; then
            warning "Failed to inspect image after pull"
        elif [[ "$current_id" != "$new_id" ]]; then
            success "Image updated successfully."
            debug "New image ID: ${new_id:0:12}"
        else
            debug "Image is up to date"
        fi
    else
        if [[ -z "$current_id" ]]; then
            error "Failed to pull image and no local image exists."
            exit 1
        else
            warning "Could not check for updates, using local image."
        fi
    fi
}

# Get the host path for mounting
get_host_path() {
    local host_path
    host_path=$(pwd) || {
        error "Failed to get current directory"
        exit 1
    }

    # Basic path validation
    if [[ ! -d "$host_path" ]]; then
        error "Current directory does not exist: $host_path"
        exit 1
    fi

    debug "Host path: $host_path"
    echo "$host_path"
}

# Show version
show_version() {
    check_docker
    check_docker_running

    if docker run --rm "$IMAGE" --version 2>/dev/null; then
        exit 0
    else
        echo "dclaude version 0.0.1 (Docker image unavailable)"
        exit 0
    fi
}

# Show help
show_help() {
    cat << EOF
dclaude - Dockerized Claude Code Launcher

Usage:
    dclaude [options] [claude-args...]

Options:
    --version    Show version information
    --update     Force update the Docker image
    --help       Show this help message
    --debug      Run with debug output

Environment Variables:
    DCLAUDE_TAG           Docker image tag to use (default: latest)
    DCLAUDE_DEBUG         Enable debug output (default: false)
    DCLAUDE_DOCKER_SOCKET Docker socket path (default: /var/run/docker.sock)
    DCLAUDE_NETWORK       Network mode: host, bridge, or auto-detect (default: auto-detect)

Examples:
    dclaude                    # Start Claude interactively
    dclaude "fix the bug"      # Run Claude with a command
    dclaude --version          # Show version
    dclaude --update           # Update Docker image
    DCLAUDE_DEBUG=true dclaude # Run with debug output

Security Note:
    This tool mounts the Docker socket, granting the container access to Docker.
    Only use in trusted environments.

For more information, visit:
    https://github.com/alanbem/dclaude
EOF
}

# Main execution
main() {
    # Parse special flags
    case "${1:-}" in
        --version)
            show_version
            ;;
        --update)
            check_docker
            check_docker_running
            docker pull "$IMAGE"
            success "Image updated successfully."
            exit 0
            ;;
        --debug)
            export DCLAUDE_DEBUG=true
            shift
            main "$@"
            ;;
        --help)
            show_help
            exit 0
            ;;
    esac

    # Show security warning if Docker socket will be mounted
    if [[ -S "$DOCKER_SOCKET" ]] && [[ "$DEBUG" == "true" ]]; then
        warning "Docker socket will be mounted - container will have Docker access"
    fi

    # Check prerequisites
    check_docker
    check_docker_running

    # Setup environment
    create_volumes
    update_image

    # Get current directory for mounting
    HOST_PATH=$(get_host_path)

    # Platform-specific settings
    local platform
    platform=$(detect_platform)
    debug "Platform detected: $platform"

    # Set network mode based on auto-detection or user preference
    local network_mode="${DCLAUDE_NETWORK:-}"
    if [[ -z "$network_mode" ]]; then
        # Auto-detect network capability
        network_mode=$(detect_network_capability)
        debug "Auto-detected network mode: $network_mode"

        # Show warning if using bridge mode
        if [[ "$network_mode" == "bridge" ]]; then
            warning "Using bridge networking mode on $platform"
            info "Bridge mode limitations:"
            info "  - Cannot access services on localhost (use host.docker.internal instead)"
            info "  - Cannot access other containers via localhost"
            info "  - Port mapping required for container services"
            info ""
            info "For better localhost access, consider:"
            info "  - macOS: Enable host networking in Docker Desktop (beta) or use OrbStack"
            info "  - Windows: Enable host networking in Docker Desktop (beta feature)"
        else
            debug "Host networking available - full localhost access enabled"
        fi
    else
        debug "Using user-specified network mode: $network_mode"
    fi
    debug "Network mode: $network_mode"

    # Prepare Docker run arguments
    DOCKER_ARGS=(
        "run"
        "--rm"
        "-it"
        # Mount current directory
        -v "${HOST_PATH}:${HOST_PATH}"
        # Mount persistent volumes
        -v "${VOLUME_PREFIX}-config:/home/claude/.config"
        -v "${VOLUME_PREFIX}-cache:/home/claude/.cache"
        -v "${VOLUME_PREFIX}-claude:/home/claude/.claude"
        # Set working directory
        -w "${HOST_PATH}"
        # Network mode
        --network="$network_mode"
        # Environment
        -e "TERM=${TERM:-xterm-256color}"
    )

    # Mount Docker socket if it exists and is a socket
    if [[ -S "$DOCKER_SOCKET" ]]; then
        DOCKER_ARGS+=(-v "${DOCKER_SOCKET}:/var/run/docker.sock")
        debug "Docker socket mounted: $DOCKER_SOCKET"
    else
        warning "Docker socket not found or not a socket: $DOCKER_SOCKET"
        warning "Container will not have Docker access"
    fi

    # Add any additional environment variables
    if [[ -n "${CLAUDE_MODEL:-}" ]]; then
        DOCKER_ARGS+=(-e "CLAUDE_MODEL=${CLAUDE_MODEL}")
    fi

    if [[ "$DEBUG" == "true" ]]; then
        debug "Docker command: docker ${DOCKER_ARGS[*]} $IMAGE $*"
    fi

    # Run Claude in Docker
    exec docker "${DOCKER_ARGS[@]}" "$IMAGE" "$@"
}

# Cleanup function
cleanup() {
    debug "Cleaning up..."
}

# Handle signals
trap cleanup EXIT
trap 'exit 130' INT
trap 'exit 143' TERM

# Run main function
main "$@"